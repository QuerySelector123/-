### 1.减少 http 请求

首先一个完整的 http 请求需要经过
DNS 查找 TCP 握手 浏览器发出 http 请求
服务器接收请求 返回响应 浏览器处理响应

通过浏览器的 network 可以看到文件越大真正下载时间所占比就越大
而文件越小 下载文件所占比就越小
所以采用多个小文件合并为一个大文件
从而减少 http 请求次数的原因

### 2.使用 http2

- 解析速度快

一般服务器解析 http1.1 请求时 采用读取字节的方式 直到遇到分隔符停止解析
而 http2 采用的是帧协议
每个帧都有表示字节帧的长度字段

- 多路复用
  http1.1 一个 TCP 连接只能发送一个请求
  而 http2 多个请求可以共用一个 TCP 连接

- 优先级
  http2 对比较紧急的请求 设置一个较高的优先级 优先处理

- 服务器推送
  当客户端发送一个请求 服务器会返回多个响应
  服务器可以提前向客户端推送 html 页面的上的资源

### 3.采用服务器进行渲染

客户端渲染 需要获取 html 文件
然后下载相应的 js 资源文件 运行生成 dom
再渲染

而服务器端 他会查看需要那些资源文件
如果有 ajax 请求 会把这些请求过来的数据填充到 html 中 进行渲染 渲染完成 把渲染完毕的 html 文件发送给客户端

### 4.静态资源使用 CDN

我们知道 当服务器离用户越远 延迟就越高
而 CDN 恰好解决这个问题
他可以在多个位置部署服务器 让用户离服务器更近 从而缩短请求

### 5.将 css 文件放在文件头部 js 文件放在底部

css 放在头部 why
因为先加载 html 再加载 css 会让用户第一眼看到没有样式的网页 为了更好的用户体验

js 文件也不是不可以放在头部
只要给 script 加上 defer 属性 异步下载 延迟执行

### 6.字体图标代替图片图标

- 字体图标文件特别小
- 字体图标是矢量图不会失真
- 设置属性比较方便 font-size color 等
  我们可以通过 fontmin-webpack 插件 压缩字体文件

### 7.多利用缓存 不重复加载相同的资源

为了更好性能 防止用户每次访问网站都要请求数据 我们可以添加 Expires 过期时间
或者 max-age 失效时间 这个是相对时间

### 8.压缩文件

压缩文件可以减少文件下载时间从而让用户有更好的用户体验

这多亏了 webpack 以及 node 的发展
让压缩文件非常方便

在 webpack 可以使用以下插件进行压缩
javascript :uglifyPlugin
css: MiniCssExtractPlugin
HTML HtmlWebpackPlugin

其实我们还可以做的更好
就是使用 gzip 压缩
可以通过 http 请求头的 Accept-Encoding 头部添加 gzip 标识来开启这功能 当然服务器也要支持这个功能

gzip 是目前最流行和最有效的压缩方法

举个例子我用 vue 开发项目构建完成后生成 app.js 文件大小 为 1.4m
使用 gzip 压缩后 只有 573kb 体积减少了 60%

### 9.图片优化

- 图片延迟加载

图片对于很多网站来说一次性加载全部图片对用户体验造成很大影响

使用图片延迟加载 当图片出现在浏览器可视区的时候再去真正加载相应的图片

- 响应式图片
  可以让浏览器根据屏幕的大小加载相应合适的图片

- 调整图片的大小

例如 你有一个 1920\*1080 的图片
用缩略图的形式展示给用户
当用户鼠标悬停 才展示全图
如果用户从未真正鼠标悬停在缩略图上 这样浪费了下载图片的时间

- 降低图片的质量
  图片 100%质量和图片 90% 质量通常看不出什么区别
  我经常使用 ps 切背景图 将图片切成 jpg 的格式 然后将其压缩为 60%的质量 基本上看不出什么区别

压缩方式 有两种
一通过 webpack 的 image-webpack-loader
二通过网站在线工具进行压缩

- 尽可能利用 css3 效果代替图片
  很多图片上的渐变阴影效果可以用 css 画出来 选择 css3 效果更好 代码大小是图片的几分之一 甚至几十分之一

- 使用 webp 格式的图片
  webp 用更优秀的图片数据压缩算法 带来更小的图片体积 并且具有无损有损的压缩模式
  alpha 透明通道 在 jpeg png 上转换效果更稳定 统一

### 10.通过 webpack 按需引入加载代码 提取第三方库代码 减少 ES6 转为 ES5 的沉余代码

懒加载 按需引入是很好的优化网页应用的方式
他实际上把你的代码在逻辑断点中分开
这样加快了初始加载数度 减轻了他的总体积 并且有些代码可能永远不会被加载

- 根据文件内容生成文件名 结合 import 动态引入组件实现按需加

### 11.减少重绘重排

浏览器渲染过程

1.解析 html 生成 dom 树

2.解析 css 生成 cssom 规则树

3.解析 js 操作 dom 树和 cssom 规则树

4.将 dom 数和 cssom 规则树合并到一起生成渲染树

5.遍历渲染树开始布局 计算每个节点的位置大小信息

6.浏览器将所有图层数据发送给 GPU GPU 将图层合成并显示在屏幕上

重排(回流)

当重新生成渲染树后 就要将渲染数每个节点绘制到屏幕上 这个过程叫做重绘

不是所有动作都会导致重排 列如改变字体大小 只会导致重绘
重排只会导致重绘 重绘不能导致重排

重排和重绘是非常昂贵的 因为在 javascript 引擎线程和 GUI 渲染线程是互斥的 他们同时只能一个在工作

什么会导致重排

- 添加或者删除可见的 dom 元素
- 元素的尺寸改变
- 元素位置改变
- 内容改变
- 浏览器窗口的改变

如何减少重绘重排

- 用 javascript 修改样式时 最好不要直接写样式
